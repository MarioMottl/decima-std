split_whitespace :: (s: string) -> array {
  parts := split(s, " ")
  out := array()
  i: int = 0
  for (i = 0; i < len(parts); i = i + 1) {
    t := trim(get(parts, i))
    if (len(t) > 0) { push(out, t) }
  }
  return out
}

swap_in_place :: (arr: array, i: int, j: int) -> void {
  tmp := get(arr, i)
  set(arr, i, get(arr, j))
  set(arr, j, tmp)
}

selection_sort_in_place :: (arr: array) -> void {
  n: int = len(arr)
  i: int = 0
  for (i = 0; i < n; i = i + 1) {
    min_i: int = i
    j: int = i + 1
    for (j = j; j < n; j = j + 1) {
      if (get(arr, j) < get(arr, min_i)) { min_i = j }
    }
    if (min_i != i) { swap_in_place(arr, i, min_i) }
  }
}

sum_abs_diff_sorted :: (left_sorted: array, right_sorted: array) -> int {
  n: int = len(left_sorted)
  total: int = 0
  i: int = 0
  for (i = 0; i < n; i = i + 1) {
    d: int = get(left_sorted, i) - get(right_sorted, i)
    if (d < 0) { d = -d }
    total = total + d
  }
  return total
}

build_value_counts :: (arr: array) -> (values: array, counts: array) {
  selection_sort_in_place(arr)
  values := array()
  counts := array()
  n: int = len(arr)
  i: int = 0

  while (i < n) {
    v := get(arr, i)
    c: int = 1
    i = i + 1

    cont: bool = true
    while (cont) {
      if (i < n) {
        if (get(arr, i) == v) {
          c = c + 1
          i = i + 1
        } else {
          cont = false
        }
      } else {
        cont = false
      }
    }

    push(values, v)
    push(counts, c)
  }

  return values, counts
}

compute_similarity_score :: (left: array, right: array) -> int {
  rc := build_value_counts(right)
  uniq_right := rc[0]
  counts_right := rc[1]

  selection_sort_in_place(left)

  i: int = 0
  j: int = 0
  nl: int = len(left)
  nu: int = len(uniq_right)
  score: int = 0

  loop: bool = true
  while (loop) {
    if (i >= nl) {
      loop = false
    } else {
      if (j >= nu) {
        loop = false
      } else {
        lv := get(left, i)
        rv := get(uniq_right, j)
        if (lv == rv) {
          score = score + lv * get(counts_right, j)
          i = i + 1
        } else {
          if (lv < rv) {
            i = i + 1
          } else {
            j = j + 1
          }
        }
      }
    }
  }

  return score
}

parse_location_lists :: (raw: string) -> (left: array, right: array) {
  lines := split(raw, "\n")
  left := array()
  right := array()
  i: int = 0
  for (i = 0; i < len(lines); i = i + 1) {
    line := trim(get(lines, i))
    if (len(line) > 0) {
      cols := split_whitespace(line)
      if (len(cols) >= 2) {
        temp_left  := get(cols, 0)
        temp_right := get(cols, 1)
        push(left, parse_int(temp_left))
        push(right, parse_int(temp_right))
      }
    }
  }
  return left, right
}

run_sample_tests :: () -> void {
  sample := "3   4\n4   3\n2   5\n1   3\n3   9\n3   3\n"
  p1 := parse_location_lists(sample)
  l1: array = p1[0]
  r1: array = p1[1]
  selection_sort_in_place(l1)
  selection_sort_in_place(r1)
  part1: int = sum_abs_diff_sorted(l1, r1)
  print("Part1 Example: ")
  print(part1)

  p2 := parse_location_lists(sample)
  l2: array = p2[0]
  r2: array = p2[1]
  part2: int = compute_similarity_score(l2, r2)
  print("Part2 Example: ")
  print(part2)
}

solve_day1 :: (input_path: string) -> (part1: int, part2: int) {
  raw := read_file(input_path)

  p1 := parse_location_lists(raw)
  left1: array = p1[0]
  right1: array = p1[1]
  selection_sort_in_place(left1)
  selection_sort_in_place(right1)
  ans1: int = sum_abs_diff_sorted(left1, right1)

  p2 := parse_location_lists(raw)
  left2: array = p2[0]
  right2: array = p2[1]
  ans2: int = compute_similarity_score(left2, right2)

  return ans1, ans2
}

main :: () -> void {
  run_sample_tests()
//  res := solve_day1("input.txt")
//  print(res[0])
//  print(res[1])
}

