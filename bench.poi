import std.core as core

Vec2 :: struct { x:int; y:int }

math {
    sq :: (x:int)->int { return x * x }
    len2 :: (v:Vec2)->int { return sq(v.x) + sq(v.y) }
}

bench_sum :: (n:int)->int {
    acc: int = 0
    i: int = 1
    for (i = 1; i <= n; i += 1) { acc = acc + i }
    return acc
}

bench_len2 :: (n:int)->int {
    v := Vec2.{3,4}
    acc: int = 0
    i: int = 0
    for (i = 0; i < n; i += 1) {
        acc = acc + math::len2(v)   // purely CPU
    }
    return acc
}

report :: (label:string, iters:int, start_ns:int, end_ns:int)->() {
    total := end_ns - start_ns
    per   := total / iters
    print(label)
    print(total)   // total ns
    print(per)     // ns/op
    return
}

main :: () {
    iters: int = 5000000   // 5e7 if it’s too slow, start at 5e6

    // warmup
    _ := bench_sum(1000000)
    _ := bench_len2(100000)

    // 1) tight integer loop
    s1 := now_ns()
    acc1 := bench_sum(iters)
    e1 := now_ns()
    report("sum 1..N", iters, s1, e1)

    // 2) proc calls + arithmetic
    it2 := iters / 10
    s2 := now_ns()
    acc2 := bench_len2(it2)
    e2 := now_ns()
    report("len2(v) call", it2, s2, e2)

    // 3) tiny ternary branch (branch predictor friendly)
    i: int = 0
    t3 := 0
    s3 := now_ns()
    for (i = 0; i < iters; i += 1) {
        t3 = t3 + ((i % 2 == 0) ? 1 : 2)
    }
    e3 := now_ns()
    report("branch ternary", iters, s3, e3)

    // use results so they aren't optimized away (your interpreter won’t, but keep the habit)
    print(acc1)
    print(acc2)
}

